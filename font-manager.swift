#!/usr/bin/swift

// fork from https://github.com/benwiggy/font-manager
// which enables wildcard `*` support, i.e.
// font-manager register *.otf

// >>> This script was originally generated by Code CoPilot AI
// And then forked and altered with grok ai, lol

// v1.2.1 now supports wildcard `*`

import Foundation
import CoreText
import AppKit
import Darwin

enum FontAction: String {
    case register = "register"
    case unregister = "unregister"
    case list = "list"
    case listExt = "list-ext"
}

func expandGlob(pattern: String) -> [String] {
    var paths = [String]()
    var globbuf = glob_t()
    if glob(pattern, GLOB_TILDE, nil, &globbuf) == 0 {
        for i in 0..<Int(globbuf.gl_matchc) {
            if let path = String(validatingUTF8: globbuf.gl_pathv[i]!) {
                paths.append(path)
            }
        }
    }
    globfree(&globbuf)
    return paths
}

func registerFont(withPath path: String) -> Bool {
    let fontURL = URL(fileURLWithPath: path)
    let fontURLs = [fontURL] as CFArray

    var registrationSuccessful = true
    CTFontManagerRegisterFontURLs(fontURLs, .persistent, true) { (urls, finished) -> Bool in
        let errorCount = CFArrayGetCount(urls)
        if errorCount > 0 {
            for i in 0..<errorCount {
                if let error = unsafeBitCast(CFArrayGetValueAtIndex(urls, i), to: CFError.self) as CFError? {
                    let errorDescription = CFErrorCopyDescription(error) as String
                    print("Failed to register font: \(errorDescription)")
                    registrationSuccessful = false
                }
            }
        }
        return finished
    }

    if registrationSuccessful {
        print("Successfully registered font at path: \(path)")
    }
    return registrationSuccessful
}

func unregisterFont(withPath path: String) -> Bool {
    let fontURL = URL(fileURLWithPath: path)
    let fontURLs = [fontURL] as CFArray

    var unregistrationSuccessful = true
    CTFontManagerUnregisterFontURLs(fontURLs, .persistent) { (urls, finished) -> Bool in
        let errorCount = CFArrayGetCount(urls)
        if errorCount > 0 {
            for i in 0..<errorCount {
                if let error = unsafeBitCast(CFArrayGetValueAtIndex(urls, i), to: CFError.self) as CFError? {
                    let errorDescription = CFErrorCopyDescription(error) as String
                    print("Failed to unregister font: \(errorDescription)")
                    unregistrationSuccessful = false
                }
            }
        }
        return finished
    }

    if unregistrationSuccessful {
        print("Successfully unregistered font at path: \(path)")
    }
    return unregistrationSuccessful
}

func listInstalledFonts() {
    let fontManager = NSFontManager.shared
    let fontFamilies = fontManager.availableFontFamilies

    print("Installed fonts:")
    for family in fontFamilies {
        print("\n\(family)")
        if let fontNames = fontManager.availableMembers(ofFontFamily: family) {
            for font in fontNames {
                if let fontName = font.first as? String {
                    print("\t\(fontName)")
                }
            }
        }
    }
}

func isNonStandardLocation(fontURL: URL) -> Bool {
    let standardPaths = [
        "/System/Library/Fonts",
        "/Library/Fonts",
        "\(NSHomeDirectory())/Library/Fonts"
    ]
    
    for path in standardPaths {
        if fontURL.path.hasPrefix(path) {
            return false
        }
    }
    return true
}

func listNonStandardLocationFonts() {
    let fontManager = NSFontManager.shared
    let fontFamilies = fontManager.availableFontFamilies

    var nonStandardFonts = [(String, String, String)]() // Tuple of (Font Family, PostScript Name, File Path)

    for family in fontFamilies {
        if let fontNames = fontManager.availableMembers(ofFontFamily: family) {
            for font in fontNames {
                if let fontName = font.first as? String {
                    let ctFont = CTFontCreateWithName(fontName as CFString, 0.0, nil)
                    if let postScriptName = CTFontCopyPostScriptName(ctFont) as String?,
                       let fontURL = CTFontDescriptorCopyAttribute(CTFontCopyFontDescriptor(ctFont), kCTFontURLAttribute) as? URL,
                       isNonStandardLocation(fontURL: fontURL) {
                        nonStandardFonts.append((family, postScriptName, fontURL.path))
                    }
                }
            }
        }
    }
    
    if nonStandardFonts.isEmpty {
        print("No fonts found in non-standard locations.")
    } else {
        print("Activated fonts in non-standard locations:")
        
        // Sort the fonts alphabetically by font family and then by PostScript name
        nonStandardFonts.sort { $0.0 < $1.0 || ($0.0 == $1.0 && $0.1 < $1.1) }
        
        var currentFamily: String?
        for (family, postScriptName, path) in nonStandardFonts {
            if currentFamily != family {
                print("\n\(family)")
                currentFamily = family
            }
            print("\t\(postScriptName)\t\(path)")
        }
    }
}

func printUsage() {
    print("Usage: font-manager.swift [register|unregister|list|list-ext] /path/to/font.ttf [/path/to/font2.ttf ...]")
}

// Main execution
let arguments = CommandLine.arguments

if arguments.count < 2 {
    printUsage()
    exit(1)
}

let action = arguments[1]

guard let fontAction = FontAction(rawValue: action) else {
    printUsage()
    exit(1)
}

switch fontAction {
case .register, .unregister:
    if arguments.count < 3 {
        printUsage()
        exit(1)
    }
    let inputPaths = Array(arguments[2...])
    var allPaths = [String]()
    for path in inputPaths {
        if path.contains("*") || path.contains("?") || path.contains("[") {
            let expanded = expandGlob(pattern: path)
            allPaths += expanded
        } else {
            allPaths.append(path)
        }
    }
    if allPaths.isEmpty {
        print("No files found matching the provided patterns.")
        exit(1)
    }
    var allSuccess = true
    for path in allPaths {
        let success: Bool
        if fontAction == .register {
            // Check if the font file exists
            let fileManager = FileManager.default
            guard fileManager.fileExists(atPath: path) else {
                print("Font file not found at path: \(path)")
                allSuccess = false
                continue
            }
            // Check if the font file has the correct permissions
            do {
                let attributes = try fileManager.attributesOfItem(atPath: path)
                if let permissions = attributes[.posixPermissions] as? NSNumber {
                    let filePermissions = permissions.uint16Value
                    let readable = (filePermissions & S_IRUSR != 0)
                    if !readable {
                        print("Font file at path: \(path) does not have read permissions.")
                        allSuccess = false
                        continue
                    }
                }
            } catch {
                print("Failed to get attributes of font file at path: \(path), error: \(error)")
                allSuccess = false
                continue
            }
            success = registerFont(withPath: path)
        } else { // unregister
            success = unregisterFont(withPath: path)
        }
        if !success {
            allSuccess = false
        }
    }
    if allSuccess {
        exit(0)
    } else {
        exit(1)
    }
case .list:
    if arguments.count != 2 {
        printUsage()
        exit(1)
    }
    listInstalledFonts()
    exit(0)
case .listExt:
    if arguments.count != 2 {
        printUsage()
        exit(1)
    }
    listNonStandardLocationFonts()
    exit(0)
}
